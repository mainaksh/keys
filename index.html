<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bitcoin Key Space Explorer - Ultra Fast</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
:root {
  --bg-primary: #0f1419;
  --bg-secondary: #1a1f2e;
  --bg-tertiary: #252b3b;
  --accent-primary: #3b82f6;
  --accent-secondary: #60a5fa;
  --text-primary: #e2e8f0;
  --text-secondary: #94a3b8;
  --text-muted: #64748b;
  --success: #10b981;
  --error: #ef4444;
  --warning: #f59e0b;
  --border: #2d3548;
  --shadow: rgba(0, 0, 0, 0.3);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
  line-height: 1.6;
  min-height: 100vh;
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  padding: 24px;
}

header {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 32px;
  margin-bottom: 24px;
  box-shadow: 0 4px 6px var(--shadow);
}

header h1 {
  font-size: 32px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 8px;
}

header p {
  color: var(--text-secondary);
  font-size: 15px;
  font-weight: 400;
}

.controls {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 24px;
  margin-bottom: 24px;
  box-shadow: 0 4px 6px var(--shadow);
}

.control-row {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  margin-bottom: 16px;
}

.control-row:last-child {
  margin-bottom: 0;
}

button {
  background: var(--accent-primary);
  color: white;
  border: none;
  padding: 10px 18px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
}

button:hover {
  background: var(--accent-secondary);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
}

button:active {
  transform: translateY(0);
}

button.secondary {
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border: 1px solid var(--border);
  box-shadow: none;
}

button.secondary:hover {
  background: var(--bg-secondary);
  border-color: var(--accent-primary);
}

input {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 10px 14px;
  border-radius: 8px;
  font-size: 14px;
  transition: all 0.2s ease;
}

input:focus {
  outline: none;
  border-color: var(--accent-primary);
  background: var(--bg-secondary);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
}

input::placeholder {
  color: var(--text-muted);
}

input[type="text"]#pageInput {
  width: 120px;
}

input[type="text"]#wifInput {
  width: 300px;
  font-family: 'Courier New', monospace;
  font-size: 13px;
}

.info {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 14px 20px;
  margin-bottom: 24px;
  font-size: 14px;
  color: var(--text-secondary);
  box-shadow: 0 2px 4px var(--shadow);
}

.debug-panel {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 20px 24px;
  margin-bottom: 24px;
  font-size: 13px;
  font-family: 'Courier New', monospace;
  box-shadow: 0 4px 6px var(--shadow);
}

.debug-panel h3 {
  color: var(--accent-primary);
  margin-bottom: 14px;
  font-size: 15px;
  font-weight: 600;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

.debug-panel .status-item {
  padding: 8px 0;
  display: flex;
  justify-content: space-between;
  border-bottom: 1px solid var(--border);
}

.debug-panel .status-item:last-child {
  border-bottom: none;
}

.status-ok {
  color: var(--success);
}

.status-fail {
  color: var(--error);
}

.table-container {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 4px 6px var(--shadow);
}

.table-wrapper {
  overflow-x: auto;
  overflow-y: visible;
}

table {
  width: 100%;
  min-width: 1200px;
  border-collapse: collapse;
}

thead {
  background: var(--bg-tertiary);
  border-bottom: 2px solid var(--border);
  position: sticky;
  top: 0;
  z-index: 10;
}

th {
  padding: 14px 16px;
  text-align: left;
  font-weight: 600;
  font-size: 12px;
  color: var(--accent-primary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  white-space: nowrap;
}

td {
  padding: 14px 16px;
  border-bottom: 1px solid var(--border);
  font-size: 13px;
  font-family: 'Courier New', monospace;
  color: var(--text-secondary);
  white-space: nowrap;
}

td a {
  color: var(--accent-primary);
  text-decoration: none;
  transition: all 0.2s ease;
  position: relative;
}

td a:hover {
  color: var(--accent-secondary);
  text-decoration: underline;
}

td a:visited {
  color: var(--accent-primary);
}

tbody tr {
  transition: background 0.15s ease;
}

tbody tr:hover {
  background: var(--bg-tertiary);
}

tbody tr:last-child td {
  border-bottom: none;
}

.highlight-row {
  background: rgba(245, 158, 11, 0.15) !important;
  border-left: 3px solid var(--warning);
}

.highlight-row:hover {
  background: rgba(245, 158, 11, 0.25) !important;
}

.label {
  color: var(--text-secondary);
  font-size: 14px;
  font-weight: 500;
}

.loading {
  text-align: center;
  padding: 40px;
  color: var(--text-muted);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

.scroll-hint {
  text-align: center;
  padding: 8px;
  font-size: 12px;
  color: var(--text-muted);
  background: var(--bg-tertiary);
  border-top: 1px solid var(--border);
}
</style>
</head>

<body>

<div class="container">
  <header>
    <h1>üîë Bitcoin Key Space Explorer</h1>
    <p>Ultra-fast deterministic secp256k1 key enumeration</p>
  </header>

  <div class="debug-panel" id="debugPanel">
    <h3>üìä System Status</h3>
    <div class="status-item">
      <span>Precomputed Tables:</span>
      <span id="precompStatus">‚è≥ Loading...</span>
    </div>
    <div class="status-item">
      <span>Crypto Engine:</span>
      <span class="status-ok">‚úÖ Ready</span>
    </div>
    <div class="status-item">
      <span>Performance:</span>
      <span class="status-ok">‚úÖ Optimized</span>
    </div>
  </div>

  <div class="controls">
    <div class="control-row">
      <button onclick="prev()">‚óÄ Previous</button>
      <button onclick="next()">Next ‚ñ∂</button>
      <span class="label">Page:</span>
      <input id="pageInput" type="text" value="1">
      <button class="secondary" onclick="gotoPage()">Go to Page</button>
      <button class="secondary" onclick="randomPage()">üé≤ Random Page</button>
    </div>
    
    <div class="control-row">
      <span class="label">WIF:</span>
      <input id="wifInput" type="text" placeholder="5... K... L...">
      <button class="secondary" onclick="decodeWifAndJump()">Decode & Jump</button>
    </div>
  </div>

  <div class="info" id="info">Precomputing lookup tables...</div>

  <div class="table-container">
    <div class="table-wrapper">
      <table>
        <thead>
          <tr>
            <th>Private Key</th>
            <th>WIF Compressed</th>
            <th>WIF Uncompressed</th>
            <th>Address (Compressed)</th>
            <th>Address (Uncompressed)</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr>
            <td colspan="5" class="loading">Initializing...</td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="scroll-hint">‚Üê Scroll horizontally to view all columns ‚Üí</div>
  </div>
</div>

<script>
'use strict';

// ================= CONSTANTS =================
const _0n = 0n;
const _1n = 1n;
const _2n = 2n;
const _3n = 3n;
const _8n = 8n;

const P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2Fn;
const N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n;
const Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798n;
const Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8n;

const KEYS_PER_PAGE = 128n;
const TOTAL_PAGES = (N - _1n) / KEYS_PER_PAGE + _1n;

// ================= BASE58 =================
const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
const BASE58_MAP = {};
for (let i = 0; i < BASE58_ALPHABET.length; i++) {
  BASE58_MAP[BASE58_ALPHABET[i]] = i;
}

function base58Encode(buffer) {
  if (buffer.length === 0) return '';
  
  let zeros = 0;
  for (let i = 0; i < buffer.length && buffer[i] === 0; i++) zeros++;
  
  let num = 0n;
  for (let i = 0; i < buffer.length; i++) {
    num = num * 256n + BigInt(buffer[i]);
  }
  
  let encoded = '';
  while (num > 0n) {
    encoded = BASE58_ALPHABET[Number(num % 58n)] + encoded;
    num /= 58n;
  }
  
  return '1'.repeat(zeros) + encoded || '1';
}

function base58Decode(string) {
  if (string.length === 0) return [];
  
  let zeros = 0;
  for (let i = 0; i < string.length && string[i] === '1'; i++) zeros++;
  
  let num = 0n;
  for (let i = 0; i < string.length; i++) {
    const digit = BASE58_MAP[string[i]];
    if (digit === undefined) throw new Error('Invalid character');
    num = num * 58n + BigInt(digit);
  }
  
  const bytes = [];
  while (num > 0n) {
    bytes.unshift(Number(num % 256n));
    num /= 256n;
  }
  
  for (let i = 0; i < zeros; i++) bytes.unshift(0);
  
  return bytes.length === 0 ? [0] : bytes;
}

// ================= SHA256 & RIPEMD160 (optimized) =================
function rotr(x, n) {
  return (x >>> n) | (x << (32 - n));
}

const SHA256_K = new Uint32Array([
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);

function sha256(data) {
  const bytes = Array.isArray(data) ? data : Array.from(data);
  const l = bytes.length * 8;
  const blocks = Math.ceil((l + 65) / 512);
  const paddedLen = blocks * 64;
  const padded = new Uint8Array(paddedLen);
  
  padded.set(bytes);
  padded[bytes.length] = 0x80;
  
  const view = new DataView(padded.buffer);
  view.setUint32(paddedLen - 4, l >>> 0, false);
  
  let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
  let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
  
  const w = new Uint32Array(64);
  
  for (let i = 0; i < blocks; i++) {
    const offset = i * 64;
    
    for (let j = 0; j < 16; j++) {
      w[j] = view.getUint32(offset + j * 4, false);
    }
    
    for (let j = 16; j < 64; j++) {
      const s0 = rotr(w[j-15], 7) ^ rotr(w[j-15], 18) ^ (w[j-15] >>> 3);
      const s1 = rotr(w[j-2], 17) ^ rotr(w[j-2], 19) ^ (w[j-2] >>> 10);
      w[j] = (w[j-16] + s0 + w[j-7] + s1) >>> 0;
    }
    
    let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7;
    
    for (let j = 0; j < 64; j++) {
      const S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25);
      const ch = (e & f) ^ (~e & g);
      const temp1 = (h + S1 + ch + SHA256_K[j] + w[j]) >>> 0;
      const S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22);
      const maj = (a & b) ^ (a & c) ^ (b & c);
      const temp2 = (S0 + maj) >>> 0;
      
      h = g; g = f; f = e; e = (d + temp1) >>> 0;
      d = c; c = b; b = a; a = (temp1 + temp2) >>> 0;
    }
    
    h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0;
    h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0;
  }
  
  return [
    h0>>>24, h0>>>16&0xff, h0>>>8&0xff, h0&0xff,
    h1>>>24, h1>>>16&0xff, h1>>>8&0xff, h1&0xff,
    h2>>>24, h2>>>16&0xff, h2>>>8&0xff, h2&0xff,
    h3>>>24, h3>>>16&0xff, h3>>>8&0xff, h3&0xff,
    h4>>>24, h4>>>16&0xff, h4>>>8&0xff, h4&0xff,
    h5>>>24, h5>>>16&0xff, h5>>>8&0xff, h5&0xff,
    h6>>>24, h6>>>16&0xff, h6>>>8&0xff, h6&0xff,
    h7>>>24, h7>>>16&0xff, h7>>>8&0xff, h7&0xff
  ];
}

function ripemd160(data) {
  const bytes = Array.isArray(data) ? data : Array.from(data);
  
  const zl = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13];
  const zr = [5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11];
  const sl = [11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6];
  const sr = [8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11];
  
  const l = bytes.length * 8;
  const blocks = Math.ceil((l + 65) / 512);
  const paddedLen = blocks * 64;
  const padded = new Uint8Array(paddedLen);
  
  padded.set(bytes);
  padded[bytes.length] = 0x80;
  
  const view = new DataView(padded.buffer);
  view.setUint32(paddedLen - 8, l >>> 0, true);
  
  let h0 = 0x67452301, h1 = 0xEFCDAB89, h2 = 0x98BADCFE, h3 = 0x10325476, h4 = 0xC3D2E1F0;
  
  const f = (j, x, y, z) => {
    if (j < 16) return x ^ y ^ z;
    if (j < 32) return (x & y) | (~x & z);
    if (j < 48) return (x | ~y) ^ z;
    if (j < 64) return (x & z) | (y & ~z);
    return x ^ (y | ~z);
  };
  
  const K = j => [0, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E][j/16|0];
  const Kh = j => [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0][j/16|0];
  
  for (let i = 0; i < blocks; i++) {
    const offset = i * 64;
    const X = new Uint32Array(16);
    for (let j = 0; j < 16; j++) {
      X[j] = view.getUint32(offset + j * 4, true);
    }
    
    let al = h0, bl = h1, cl = h2, dl = h3, el = h4;
    let ar = h0, br = h1, cr = h2, dr = h3, er = h4;
    
    for (let j = 0; j < 80; j++) {
      let tl = (al + f(j, bl, cl, dl) + X[zl[j]] + K(j)) >>> 0;
      tl = (((tl << sl[j]) | (tl >>> (32 - sl[j]))) + el) >>> 0;
      al = el; el = dl; dl = ((cl << 10) | (cl >>> 22)) >>> 0; cl = bl; bl = tl;
      
      let tr = (ar + f(79 - j, br, cr, dr) + X[zr[j]] + Kh(j)) >>> 0;
      tr = (((tr << sr[j]) | (tr >>> (32 - sr[j]))) + er) >>> 0;
      ar = er; er = dr; dr = ((cr << 10) | (cr >>> 22)) >>> 0; cr = br; br = tr;
    }
    
    const t = (h1 + cl + dr) >>> 0;
    h1 = (h2 + dl + er) >>> 0;
    h2 = (h3 + el + ar) >>> 0;
    h3 = (h4 + al + br) >>> 0;
    h4 = (h0 + bl + cr) >>> 0;
    h0 = t;
  }
  
  return [
    h0&0xff, h0>>>8&0xff, h0>>>16&0xff, h0>>>24,
    h1&0xff, h1>>>8&0xff, h1>>>16&0xff, h1>>>24,
    h2&0xff, h2>>>8&0xff, h2>>>16&0xff, h2>>>24,
    h3&0xff, h3>>>8&0xff, h3>>>16&0xff, h3>>>24,
    h4&0xff, h4>>>8&0xff, h4>>>16&0xff, h4>>>24
  ];
}

function hash160(data) {
  return ripemd160(sha256(data));
}

function hash256(data) {
  return sha256(sha256(data));
}

// ================= SECP256K1 WITH PRECOMPUTATION =================
const mod = (a, b = P) => {
  const result = a % b;
  return result >= _0n ? result : b + result;
};

function inv(a, m = P) {
  if (a === _0n || m <= _0n) throw new Error('Invalid modular inverse');
  let t = _0n, nt = _1n, r = m, nr = mod(a, m);
  while (nr !== _0n) {
    const q = r / nr;
    [t, nt] = [nt, t - q * nt];
    [r, nr] = [nr, r % nr];
  }
  return mod(t, m);
}

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  
  add(other) {
    if (!other || !other.x) return this;
    if (!this.x) return other;
    
    const { x: x1, y: y1 } = this;
    const { x: x2, y: y2 } = other;
    
    let s;
    if (x1 === x2) {
      if (y1 === y2) {
        s = mod(mod(_3n * x1 * x1) * inv(_2n * y1));
      } else {
        return new Point(_0n, _0n);
      }
    } else {
      s = mod((y2 - y1) * inv(x2 - x1));
    }
    
    const x3 = mod(s * s - x1 - x2);
    const y3 = mod(s * (x1 - x3) - y1);
    
    return new Point(x3, y3);
  }
  
  toBytes(compressed = true) {
    const xHex = this.x.toString(16).padStart(64, '0');
    if (compressed) {
      const prefix = (this.y & _1n) ? '03' : '02';
      return hexToBytes(prefix + xHex);
    }
    const yHex = this.y.toString(16).padStart(64, '0');
    return hexToBytes('04' + xHex + yHex);
  }
}

const G = new Point(Gx, Gy);
let PRECOMP = null;

// Precompute G*1, G*2, G*4, ... G*2^255 for fast multiplication
function precomputeG() {
  console.time('Precomputation');
  const table = [G];
  let current = G;
  
  for (let i = 1; i < 256; i++) {
    current = current.add(current); // Double
    table.push(current);
  }
  
  console.timeEnd('Precomputation');
  return table;
}

// Ultra-fast multiplication using precomputed table
function fastMultiply(k) {
  if (!PRECOMP) PRECOMP = precomputeG();
  
  let result = new Point(_0n, _0n);
  let bit = 0;
  
  while (k > _0n) {
    if (k & _1n) {
      result = result.add(PRECOMP[bit]);
    }
    k >>= _1n;
    bit++;
  }
  
  return result;
}

// ================= UTILITIES =================
function hexToBytes(hex) {
  const bytes = [];
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(parseInt(hex.substr(i, 2), 16));
  }
  return bytes;
}

function bigIntToBytes(n, len = 32) {
  const bytes = [];
  for (let i = 0; i < len; i++) {
    bytes.unshift(Number(n & 0xFFn));
    n >>= 8n;
  }
  return bytes;
}

function checksum(payload) {
  return hash256(payload).slice(0, 4);
}

// ================= BITCOIN FUNCTIONS =================
function privateKeyToWIF(key, compressed = true) {
  const keyBytes = bigIntToBytes(key);
  const payload = compressed ? [0x80, ...keyBytes, 0x01] : [0x80, ...keyBytes];
  const check = checksum(payload);
  return base58Encode([...payload, ...check]);
}

function privateKeyToAddress(key, compressed = true) {
  const point = fastMultiply(key);
  const pubKey = point.toBytes(compressed);
  const h = hash160(pubKey);
  const payload = [0x00, ...h];
  const check = checksum(payload);
  return base58Encode([...payload, ...check]);
}

function wifToPrivateKey(wif) {
  const decoded = base58Decode(wif);
  
  if (decoded[0] !== 0x80) throw new Error('Invalid WIF');
  if (decoded.length !== 37 && decoded.length !== 38) throw new Error('Invalid WIF length');
  
  const payload = decoded.slice(0, -4);
  const check = decoded.slice(-4);
  const expectedCheck = checksum(payload);
  
  for (let i = 0; i < 4; i++) {
    if (check[i] !== expectedCheck[i]) throw new Error('Invalid checksum');
  }
  
  const keyBytes = payload.length === 34 ? payload.slice(1, 33) : payload.slice(1);
  
  let key = _0n;
  for (let b of keyBytes) key = (key << 8n) + BigInt(b);
  
  if (key <= _0n || key >= N) throw new Error('Key out of range');
  
  return key;
}

// ================= UI FUNCTIONS =================
let page = 1n;

function render(p, target = null) {
  const tbody = document.getElementById('tbody');
  const info = document.getElementById('info');
  
  page = p < 1n ? 1n : p > TOTAL_PAGES ? TOTAL_PAGES : p;
  const start = (page - 1n) * KEYS_PER_PAGE + 1n;
  const end = start + KEYS_PER_PAGE - 1n;
  
  info.textContent = `Showing keys ${start} ‚Äì ${end} | Page ${page} of ${TOTAL_PAGES}`;
  info.style.color = "var(--text-secondary)";
  
  tbody.innerHTML = "";
  
  const startTime = performance.now();
  
  for (let i = start; i <= end; i++) {
    const tr = document.createElement("tr");
    if (target && i === target) tr.className = "highlight-row";
    
    const wifComp = privateKeyToWIF(i, true);
    const wifUncomp = privateKeyToWIF(i, false);
    const addrComp = privateKeyToAddress(i, true);
    const addrUncomp = privateKeyToAddress(i, false);
    
    tr.innerHTML = `
      <td>${i}</td>
      <td>${wifComp}</td>
      <td>${wifUncomp}</td>
      <td><a href="https://blockchain.com/btc/address/${addrComp}" target="_blank" rel="noopener">${addrComp}</a></td>
      <td><a href="https://blockchain.com/btc/address/${addrUncomp}" target="_blank" rel="noopener">${addrUncomp}</a></td>
    `;
    
    tbody.appendChild(tr);
  }
  
  const elapsed = (performance.now() - startTime).toFixed(0);
  console.log(`Rendered page in ${elapsed}ms`);
}

function next() { render(page + 1n); }
function prev() { render(page - 1n); }

function gotoPage() {
  const pageInput = document.getElementById('pageInput');
  const info = document.getElementById('info');
  try {
    const pageNum = BigInt(pageInput.value || 1);
    render(pageNum);
  } catch(e) {
    info.textContent = "‚ùå Invalid page number";
    info.style.color = "var(--error)";
  }
}

function randomPage() {
  const randomBigInt = () => {
    const bytes = new Uint8Array(32);
    crypto.getRandomValues(bytes);
    let n = _0n;
    for (let b of bytes) n = (n << 8n) + BigInt(b);
    return n % TOTAL_PAGES + 1n;
  };
  render(randomBigInt());
}

function decodeWifAndJump() {
  const wifInput = document.getElementById('wifInput');
  const info = document.getElementById('info');
  try {
    const key = wifToPrivateKey(wifInput.value.trim());
    const targetPage = (key - 1n) / KEYS_PER_PAGE + 1n;
    render(targetPage, key);
    info.textContent = `‚úÖ Decoded WIF ‚Üí private key ${key}`;
    info.style.color = "var(--success)";
  } catch (e) {
    info.textContent = "‚ùå " + e.message;
    info.style.color = "var(--error)";
  }
}

// ================= INITIALIZE =================
setTimeout(() => {
  document.getElementById('precompStatus').innerHTML = '<span class="status-ok">‚è≥ Computing...</span>';
  
  setTimeout(() => {
    PRECOMP = precomputeG();
    document.getElementById('precompStatus').innerHTML = '<span class="status-ok">‚úÖ Ready (256 points)</span>';
    
    console.log('Testing key 1...');
    const t0 = performance.now();
    const addr1c = privateKeyToAddress(1n, true);
    const addr1u = privateKeyToAddress(1n, false);
    console.log(`First key took ${(performance.now() - t0).toFixed(1)}ms`);
    console.log('Compressed:  ', addr1c, addr1c === '1EHNa6Q4Jz2uvNExL497mE43ikXhwF6kZm' ? '‚úÖ' : '‚ùå');
    console.log('Uncompressed:', addr1u, addr1u === '1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH' ? '‚úÖ' : '‚ùå');
    
    render(1n);
  }, 100);
}, 100);
</script>
</body>
</html>